<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>Flappy Bird - Modern Edition (Improved)</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap"
    rel="stylesheet"
  />
  <style>
    * { box-sizing: border-box; }

    body, html {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .particles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: -1;
    }

    .particle {
      position: absolute;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      animation: float 6s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
      50% { transform: translateY(-100px) rotate(180deg); opacity: 1; }
    }

    .game-container {
      position: relative;
      border-radius: 24px;
      overflow: hidden;
      box-shadow:
        0 25px 50px -12px rgba(0, 0, 0, 0.25),
        0 0 0 1px rgba(255, 255, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    canvas { display: block; background: transparent; }

    .ui-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }

    .score-display {
      position: absolute;
      top: 28px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 48px;
      font-weight: 800;
      text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 15;
      will-change: transform;
    }

    .score-pop {
      animation: scorePop 120ms ease-out;
    }

    @keyframes scorePop {
      0% { transform: translateX(-50%) scale(1); }
      60% { transform: translateX(-50%) scale(1.12); }
      100% { transform: translateX(-50%) scale(1); }
    }

    .hud-row {
      position: absolute;
      top: 24px;
      right: 24px;
      display: flex;
      gap: 10px;
      z-index: 16;
      pointer-events: none;
      opacity: 0.9;
      color: rgba(255,255,255,0.95);
      font-size: 12px;
      font-weight: 700;
      text-shadow: 0 2px 10px rgba(0,0,0,0.25);
    }

    .pill {
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.16);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
    }

    .menu-panel {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 36px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      max-width: 360px;
      animation: slideIn 0.25s ease-out;
    }

    @keyframes slideIn {
      from { transform: scale(0.96); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .menu-title {
      font-size: 34px;
      font-weight: 800;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 14px;
    }

    .menu-subtitle {
      font-size: 15px;
      color: #666;
      margin-bottom: 10px;
    }

    .menu-action {
      font-size: 13px;
      color: #777;
      font-weight: 700;
      margin-top: 10px;
    }

    .score-text {
      font-size: 22px;
      color: #333;
      margin: 10px 0;
      font-weight: 700;
    }

    .best-score {
      font-size: 13px;
      color: #666;
      margin-top: 8px;
    }

    .toggle-row {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      font-size: 12px;
      color: #555;
      font-weight: 600;
    }

    .toggle {
      pointer-events: auto;
      user-select: none;
      cursor: pointer;
      background: rgba(0,0,0,0.06);
      border: 1px solid rgba(0,0,0,0.08);
      padding: 8px 10px;
      border-radius: 12px;
    }

    .toggle input { vertical-align: middle; }

    .pulse { animation: pulse 1.8s infinite; }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    @media (max-width: 480px) {
      .menu-panel { padding: 28px 22px; max-width: 300px; }
      .menu-title { font-size: 28px; }
      .score-display { font-size: 40px; top: 22px; }
      .hud-row { top: 18px; right: 16px; }
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>

  <div class="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
      <div class="score-display" id="scoreDisplay" style="display:none;">0</div>

      <div class="hud-row" id="hudRow" style="display:none;">
        <div class="pill" id="modePill">Mode: Classic</div>
        <div class="pill" id="multPill">x1</div>
      </div>

      <div class="menu-panel" id="startMenu">
        <div class="menu-title">Flappy Bird</div>
        <div class="menu-subtitle">Modern Edition (Improved Feel)</div>
        <div class="menu-action pulse">Tap / Click / Space to start</div>

        <div class="toggle-row">
          <label class="toggle">
            <input type="checkbox" id="dailyToggle" />
            Daily challenge
          </label>
          <label class="toggle">
            <input type="checkbox" id="bonusToggle" checked />
            Near-miss bonus
          </label>
          <label class="toggle">
            <input type="checkbox" id="soundToggle" checked />
            Sound
          </label>
        </div>
      </div>

      <div class="menu-panel" id="gameOverMenu" style="display:none;">
        <div class="menu-title">Game Over</div>
        <div class="score-text" id="finalScore">Score: 0</div>
        <div class="best-score" id="bestScore">Best: 0</div>
        <div class="best-score" id="achievementLine" style="display:none;"></div>
        <div class="menu-action pulse">Tap to play again</div>
      </div>
    </div>
  </div>

  <script>
    // -------------------------
    // Particles (unchanged idea, minor cleanup)
    // -------------------------
    function createParticles() {
      const container = document.getElementById('particles');
      container.innerHTML = '';
      for (let i = 0; i < 20; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        p.style.left = (Math.random() * 100) + '%';
        const s = (Math.random() * 4 + 2);
        p.style.width = p.style.height = s + 'px';
        p.style.animationDelay = (Math.random() * 6) + 's';
        p.style.animationDuration = (Math.random() * 3 + 4) + 's';
        container.appendChild(p);
      }
    }

    // -------------------------
    // Canvas + sizing
    // -------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });

    function resizeCanvas() {
      const w = Math.min(420, window.innerWidth - 40);
      const h = Math.min(640, window.innerHeight - 40);
      canvas.width = Math.max(280, w);
      canvas.height = Math.max(420, h);
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      const prevW = canvas.width, prevH = canvas.height;
      resizeCanvas();
      // Preserve relative bird position when resizing mid-session (best-effort)
      if (state.bird) {
        state.bird.y = state.bird.y * (canvas.height / prevH);
      }
    });

    // roundRect fallback (older browsers)
    function roundRectPath(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w * 0.5, h * 0.5);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function fillRoundRect(ctx, x, y, w, h, r) {
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();
      } else {
        roundRectPath(ctx, x, y, w, h, r);
        ctx.fill();
      }
    }

    function strokeRoundRect(ctx, x, y, w, h, r) {
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.stroke();
      } else {
        roundRectPath(ctx, x, y, w, h, r);
        ctx.stroke();
      }
    }

    // -------------------------
    // UI elements
    // -------------------------
    const scoreDisplay = document.getElementById('scoreDisplay');
    const hudRow = document.getElementById('hudRow');
    const modePill = document.getElementById('modePill');
    const multPill = document.getElementById('multPill');

    const startMenu = document.getElementById('startMenu');
    const gameOverMenu = document.getElementById('gameOverMenu');
    const finalScore = document.getElementById('finalScore');
    const bestScore = document.getElementById('bestScore');
    const achievementLine = document.getElementById('achievementLine');

    const dailyToggle = document.getElementById('dailyToggle');
    const bonusToggle = document.getElementById('bonusToggle');
    const soundToggle = document.getElementById('soundToggle');

    // Persist toggles
    dailyToggle.checked = localStorage.getItem('flappyDaily') === '1';
    bonusToggle.checked = localStorage.getItem('flappyBonus') !== '0';
    soundToggle.checked = localStorage.getItem('flappySound') !== '0';

    dailyToggle.addEventListener('change', () => localStorage.setItem('flappyDaily', dailyToggle.checked ? '1' : '0'));
    bonusToggle.addEventListener('change', () => localStorage.setItem('flappyBonus', bonusToggle.checked ? '1' : '0'));
    soundToggle.addEventListener('change', () => localStorage.setItem('flappySound', soundToggle.checked ? '1' : '0'));

    // -------------------------
    // Audio (Tone.js, but guarded + user-gesture safe)
    // -------------------------
    let ToneReady = false;
    let synth = {
      flap: { triggerAttackRelease: () => {} },
      score: { triggerAttackRelease: () => {} },
      hit: { triggerAttackRelease: () => {} },
      bonus: { triggerAttackRelease: () => {} },
    };

    function ensureAudioUnlocked() {
      if (!ToneReady || !soundToggle.checked) return;
      // Tone.start() needs a user gesture; call inside input handler.
      try { window.Tone.start(); } catch (_) {}
    }

    function initTone() {
      if (!window.Tone) return;
      ToneReady = true;

      synth.flap = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.005, decay: 0.08, sustain: 0.2, release: 0.08 }
      }).toDestination();

      synth.score = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.005, decay: 0.09, sustain: 0.05, release: 0.09 }
      }).toDestination();

      synth.bonus = new Tone.Synth({
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 0.005, decay: 0.06, sustain: 0.0, release: 0.06 }
      }).toDestination();

      synth.hit = new Tone.MembraneSynth({
        envelope: { attack: 0.001, decay: 0.2, sustain: 0.0, release: 0.1 }
      }).toDestination();
    }

    // Load Tone.js
    const toneScript = document.createElement('script');
    toneScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js';
    toneScript.onload = initTone;
    document.head.appendChild(toneScript);

    // -------------------------
    // Deterministic RNG (for Daily Challenge)
    // -------------------------
    function hashStringToSeed(str) {
      // Small deterministic hash -> 32-bit seed
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0);
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function todayKey() {
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }

    // -------------------------
    // Game constants (tuned + time-based)
    // -------------------------
    const GROUND_HEIGHT = 60;

    const BIRD = {
      w: 40,
      h: 30,
      // hitbox inset makes collisions fairer
      hitInsetX: 8,
      hitInsetY: 6
    };

    const PIPE = {
      w: 62,
      capH: 26
    };

    const PHYS = {
      gravity: 1800,        // px/s^2
      flapImpulse: -520,    // px/s
      maxFallSpeed: 900,    // px/s
      maxRiseSpeed: -700    // px/s
    };

    // Difficulty curve caps (keeps simplicity)
    const DIFF = {
      baseSpeed: 170,        // px/s
      maxSpeed: 280,
      baseGap: 150,          // px
      minGap: 122,
      baseInterval: 1.25,    // seconds between pipe pairs
      minInterval: 0.95
    };

    const FEEL = {
      shakeMag: 3,
      shakeTime: 0.18,         // seconds
      hitFlashTime: 0.14,      // seconds
      topClamp: 0,             // allow clamp at ceiling without instant death
      deathLockTime: 0.25      // seconds before showing game over
    };

    // Near-miss bonus (optional)
    const BONUS = {
      enabled: true,
      nearMissMargin: 18, // px to pipe edge to count as "near"
      points: 1,
      comboWindow: 2.0,   // seconds; if you bonus repeatedly, multiplier increases
      maxMultiplier: 3
    };

    // -------------------------
    // State
    // -------------------------
    const state = {
      bird: null,
      pipes: [],
      score: 0,
      best: Number(localStorage.getItem('flappyBest') || 0),
      gameState: 'start', // 'start' | 'playing' | 'over'
      time: 0,
      accumulator: 0,
      lastTs: 0,
      shakeT: 0,
      flashT: 0,

      pipeTimer: 0,
      rng: Math.random,

      // bonus
      comboMult: 1,
      comboT: 0,
      lastBonusAtScore: -1,

      // input
      bufferedFlap: false,
      bufferT: 0
    };

    function setModePills() {
      const mode = dailyToggle.checked ? `Daily ${todayKey()}` : 'Classic';
      modePill.textContent = `Mode: ${mode}`;
    }

    function resetRun() {
      const seed = dailyToggle.checked
        ? hashStringToSeed('daily:' + todayKey())
        : (Math.random() * 0xFFFFFFFF) >>> 0;

      state.rng = mulberry32(seed);

      state.bird = {
        x: 80,
        y: canvas.height * 0.42,
        vy: 0,
        rot: 0,
        scale: 1
      };

      state.pipes = [];
      state.score = 0;
      state.time = 0;
      state.pipeTimer = 0;
      state.shakeT = 0;
      state.flashT = 0;

      state.comboMult = 1;
      state.comboT = 0;
      state.lastBonusAtScore = -1;

      scoreDisplay.textContent = '0';
      multPill.textContent = 'x1';
      scoreDisplay.classList.remove('score-pop');
      achievementLine.style.display = 'none';
      setModePills();
    }

    function difficultyForScore(score) {
      // Smooth ramp: speed increases quickly early, then tapers.
      const t = 1 - Math.exp(-score / 18); // 0..~1
      const speed = DIFF.baseSpeed + (DIFF.maxSpeed - DIFF.baseSpeed) * t;
      const gap = DIFF.baseGap - (DIFF.baseGap - DIFF.minGap) * (t * 0.9);
      const interval = DIFF.baseInterval - (DIFF.baseInterval - DIFF.minInterval) * (t * 0.85);
      return { speed, gap, interval };
    }

    function spawnPipePair() {
      const { gap } = difficultyForScore(state.score);

      const padTop = 52;
      const padBottom = GROUND_HEIGHT + 52;
      const usable = canvas.height - padTop - padBottom - gap;

      // Avoid extreme pipes early: blend random toward center for low score
      const centerBias = Math.max(0, 1 - state.score / 20); // 1 early -> 0 later
      const r = state.rng();
      const biased = (r * (1 - centerBias)) + (0.5 * centerBias);

      const topH = padTop + Math.floor(biased * usable);

      const x = canvas.width + 20;
      state.pipes.push({
        x,
        topH,
        gap,
        passed: false,
        bonusChecked: false
      });
    }

    // -------------------------
    // Collision helpers (fairer hitboxes)
    // -------------------------
    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function birdHitRect() {
      return {
        x: state.bird.x + BIRD.hitInsetX,
        y: state.bird.y + BIRD.hitInsetY,
        w: BIRD.w - BIRD.hitInsetX * 2,
        h: BIRD.h - BIRD.hitInsetY * 2
      };
    }

    function checkCollisions() {
      const b = birdHitRect();

      // Ground
      if (state.bird.y + BIRD.h >= canvas.height - GROUND_HEIGHT) return true;

      // Pipes
      for (const p of state.pipes) {
        const topRect = { x: p.x, y: 0, w: PIPE.w, h: p.topH };
        const bottomY = p.topH + p.gap;
        const bottomRect = { x: p.x, y: bottomY, w: PIPE.w, h: canvas.height - bottomY - GROUND_HEIGHT };

        // Slightly inset pipes too (fairness)
        const inset = 3;
        topRect.x += inset; topRect.w -= inset * 2;
        bottomRect.x += inset; bottomRect.w -= inset * 2;

        if (rectsOverlap(b, topRect) || rectsOverlap(b, bottomRect)) return true;
      }

      return false;
    }

    // -------------------------
    // Scoring + bonus (optional)
    // -------------------------
    function addScore(points) {
      state.score += points;
      scoreDisplay.textContent = String(state.score);

      // pop animation
      scoreDisplay.classList.remove('score-pop');
      // force reflow
      void scoreDisplay.offsetWidth;
      scoreDisplay.classList.add('score-pop');

      if (soundToggle.checked) synth.score.triggerAttackRelease('E6', '16n');
    }

    function grantBonus() {
      // combo system: repeated near-misses within window increase multiplier (caps)
      state.comboMult = Math.min(BONUS.maxMultiplier, state.comboMult + 1);
      state.comboT = BONUS.comboWindow;
      multPill.textContent = 'x' + state.comboMult;

      addScore(BONUS.points * state.comboMult);
      if (soundToggle.checked) synth.bonus.triggerAttackRelease('G6', '32n');
    }

    function updateScoreAndBonus(dt) {
      const b = birdHitRect();

      if (state.comboT > 0) {
        state.comboT -= dt;
        if (state.comboT <= 0) {
          state.comboMult = 1;
          multPill.textContent = 'x1';
        }
      }

      for (const p of state.pipes) {
        if (!p.passed && p.x + PIPE.w < state.bird.x) {
          p.passed = true;
          addScore(1);
        }

        // Near-miss: when bird x overlaps pipe and bird is close to gap edge.
        if (!bonusToggle.checked || p.bonusChecked) continue;

        const withinX =
          (b.x + b.w > p.x) && (b.x < p.x + PIPE.w);

        if (!withinX) continue;

        const gapTop = p.topH;
        const gapBottom = p.topH + p.gap;

        // distance from bird hitbox to gap edges
        const distToTopEdge = Math.abs(b.y - gapTop);
        const distToBottomEdge = Math.abs((b.y + b.h) - gapBottom);

        const isNear =
          distToTopEdge <= BONUS.nearMissMargin ||
          distToBottomEdge <= BONUS.nearMissMargin;

        // Prevent repeated triggers for same pipe pair
        // Only allow once after the base score for that pipe is earned or during pass
        if (isNear && state.score !== state.lastBonusAtScore) {
          p.bonusChecked = true;
          state.lastBonusAtScore = state.score;
          grantBonus();
        }
      }
    }

    // -------------------------
    // Input
    // -------------------------
    function requestFlap() {
      ensureAudioUnlocked();

      // Buffer flaps slightly so taps during transitions are not lost.
      state.bufferedFlap = true;
      state.bufferT = 0.12;
    }

    function consumeBufferedFlap() {
      if (!state.bufferedFlap) return false;
      state.bufferedFlap = false;
      state.bufferT = 0;
      return true;
    }

    function flapNow() {
      if (state.gameState === 'start' || state.gameState === 'over') {
        startGame();
        return;
      }
      if (state.gameState !== 'playing') return;

      state.bird.vy = PHYS.flapImpulse;
      state.bird.scale = 1.10;
      if (soundToggle.checked) synth.flap.triggerAttackRelease('C5', '16n');
    }

    // -------------------------
    // State transitions
    // -------------------------
    function startGame() {
      resetRun();
      state.gameState = 'playing';

      startMenu.style.display = 'none';
      gameOverMenu.style.display = 'none';
      scoreDisplay.style.display = 'block';
      hudRow.style.display = 'flex';

      // Give the player an immediate pipe after a short moment
      state.pipeTimer = 0.6;
      flapNow(); // start with a satisfying impulse (still Flappy mechanics)
    }

    function endGame() {
      if (state.gameState === 'over') return;
      state.gameState = 'over';

      if (soundToggle.checked) synth.hit.triggerAttackRelease('C2', '8n');

      state.shakeT = FEEL.shakeTime;
      state.flashT = FEEL.hitFlashTime;

      if (state.score > state.best) {
        state.best = state.score;
        localStorage.setItem('flappyBest', String(state.best));
      }

      // Achievements (very lightweight)
      const unlocked = [];
      const achKey = 'flappyAch';
      const ach = JSON.parse(localStorage.getItem(achKey) || '{}');

      function unlock(id, label) {
        if (ach[id]) return;
        ach[id] = true;
        unlocked.push(label);
      }

      if (state.score >= 10) unlock('score10', 'Achievement: 10+!');
      if (state.score >= 25) unlock('score25', 'Achievement: 25+!');
      if (state.score >= 50) unlock('score50', 'Achievement: 50+!');
      if (state.score > 0 && !bonusToggle.checked) unlock('nobonus', 'Achievement: Pure run (no bonus)');
      localStorage.setItem(achKey, JSON.stringify(ach));

      setTimeout(() => {
        scoreDisplay.style.display = 'none';
        hudRow.style.display = 'none';
        finalScore.textContent = `Score: ${state.score}`;
        bestScore.textContent = `Best: ${state.best}`;

        if (unlocked.length) {
          achievementLine.textContent = unlocked.join(' â€¢ ');
          achievementLine.style.display = 'block';
        } else {
          achievementLine.style.display = 'none';
        }

        gameOverMenu.style.display = 'block';
      }, Math.floor(FEEL.deathLockTime * 1000));
    }

    // -------------------------
    // Update (time-based)
    // -------------------------
    function update(dt) {
      // buffered input countdown
      if (state.bufferT > 0) {
        state.bufferT -= dt;
        if (state.bufferT <= 0) {
          state.bufferT = 0;
          state.bufferedFlap = false;
        }
      }

      if (state.gameState !== 'playing') return;

      const d = difficultyForScore(state.score);
      const speed = d.speed;

      // Bird physics
      if (consumeBufferedFlap()) flapNow();

      state.bird.vy += PHYS.gravity * dt;
      state.bird.vy = Math.min(PHYS.maxFallSpeed, Math.max(PHYS.maxRiseSpeed, state.bird.vy));
      state.bird.y += state.bird.vy * dt;

      // ceiling clamp (no instant death)
      if (state.bird.y < FEEL.topClamp) {
        state.bird.y = FEEL.topClamp;
        state.bird.vy = Math.max(0, state.bird.vy);
      }

      // rotation + scale settle
      state.bird.rot = Math.min(Math.max(-0.45, state.bird.vy * 0.0012), 0.85);
      state.bird.scale = Math.max(1, state.bird.scale - dt * 0.9);

      // Pipes
      state.pipeTimer -= dt;
      if (state.pipeTimer <= 0) {
        spawnPipePair();
        state.pipeTimer = d.interval;
      }

      for (let i = state.pipes.length - 1; i >= 0; i--) {
        state.pipes[i].x -= speed * dt;
        if (state.pipes[i].x + PIPE.w < -40) {
          state.pipes.splice(i, 1);
        }
      }

      updateScoreAndBonus(dt);

      // Collisions
      if (checkCollisions()) endGame();

      state.time += dt;
    }

    // -------------------------
    // Draw
    // -------------------------
    function drawCloud(x, y, scale) {
      ctx.save();
      ctx.scale(scale, scale);
      x /= scale; y /= scale;

      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2);
      ctx.arc(x + 20, y, 20, 0, Math.PI * 2);
      ctx.arc(x + 40, y, 15, 0, Math.PI * 2);
      ctx.arc(x + 20, y - 15, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawModernPipePair(p) {
      // Top pipe
      drawPipe(p.x, 0, PIPE.w, p.topH, true);
      // Bottom pipe
      const bottomY = p.topH + p.gap;
      drawPipe(p.x, bottomY, PIPE.w, canvas.height - bottomY - GROUND_HEIGHT, false);
    }

    function drawPipe(x, y, w, h, isTop) {
      const gradient = ctx.createLinearGradient(x, 0, x + w, 0);
      gradient.addColorStop(0, '#43A047');
      gradient.addColorStop(0.5, '#66BB6A');
      gradient.addColorStop(1, '#43A047');

      ctx.fillStyle = gradient;
      ctx.strokeStyle = '#2E7D32';
      ctx.lineWidth = 2;

      fillRoundRect(ctx, x, y, w, h, 8);
      strokeRoundRect(ctx, x, y, w, h, 8);

      // Cap
      const capY = isTop ? (y + h - PIPE.capH) : y;
      ctx.fillStyle = '#5CBF60';
      fillRoundRect(ctx, x - 6, capY, w + 12, PIPE.capH, 12);
      strokeRoundRect(ctx, x - 6, capY, w + 12, PIPE.capH, 12);

      // Highlight strip
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(x + 6, y + 4, 8, Math.max(0, h - 8));
    }

    function drawGround(groundOffsetPx) {
      const y = canvas.height - GROUND_HEIGHT;

      const groundGradient = ctx.createLinearGradient(0, y, 0, canvas.height);
      groundGradient.addColorStop(0, '#8D6E63');
      groundGradient.addColorStop(1, '#5D4037');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, y, canvas.width, GROUND_HEIGHT);

      ctx.fillStyle = '#6D4C41';
      for (let i = 0; i < Math.ceil(canvas.width / 30) + 2; i++) {
        const x = (groundOffsetPx % 30) + i * 30;
        ctx.fillRect(x, y + 10, 25, 10);
        ctx.fillRect(x + 5, y + 25, 15, 8);
      }

      ctx.strokeStyle = '#A1887F';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }

    function drawBird(t) {
      const wingFlap = Math.sin(t * 10) * 0.28;

      ctx.save();
      ctx.translate(state.bird.x + BIRD.w / 2, state.bird.y + BIRD.h / 2);
      ctx.rotate(state.bird.rot);
      ctx.scale(state.bird.scale, state.bird.scale);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.10)';
      ctx.beginPath();
      ctx.ellipse(0, 8, BIRD.w / 2 - 2, BIRD.h / 2 - 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body
      const birdGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, BIRD.w / 2);
      birdGradient.addColorStop(0, '#FFE082');
      birdGradient.addColorStop(1, '#FF9800');
      ctx.fillStyle = birdGradient;

      ctx.beginPath();
      ctx.ellipse(0, 0, BIRD.w / 2, BIRD.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wing
      ctx.fillStyle = '#FF7043';
      ctx.beginPath();
      ctx.ellipse(-8, 0, 12, 8, wingFlap, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#FF5722';
      ctx.beginPath();
      ctx.moveTo(BIRD.w / 2 - 5, 0);
      ctx.lineTo(BIRD.w / 2 + 8, 0);
      ctx.lineTo(BIRD.w / 2 - 2, 6);
      ctx.closePath();
      ctx.fill();

      // Eye
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(5, -5, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(7, -3, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(8, -4, 1, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function draw() {
      ctx.save();

      // Shake
      if (state.shakeT > 0) {
        const mag = FEEL.shakeMag * (state.shakeT / FEEL.shakeTime);
        const dx = (Math.random() - 0.5) * mag;
        const dy = (Math.random() - 0.5) * mag;
        ctx.translate(dx, dy);
      }

      // Sky
      const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
      sky.addColorStop(0, '#87CEEB');
      sky.addColorStop(0.5, '#98D8E8');
      sky.addColorStop(1, '#B8E6F0');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Clouds
      ctx.fillStyle = 'rgba(255, 255, 255, 0.65)';
      const cloudOffset = (state.time * 24) % (canvas.width + 140);
      drawCloud(cloudOffset - 60, 84, 0.8);
      drawCloud(cloudOffset + 150, 120, 1.2);
      drawCloud(cloudOffset + 360, 100, 1.0);

      // Pipes
      for (const p of state.pipes) drawModernPipePair(p);

      // Ground (scrolls with speed)
      const speed = difficultyForScore(state.score).speed;
      const groundOffsetPx = -(state.time * speed);
      drawGround(groundOffsetPx);

      // Bird
      drawBird(state.time);

      // Hit flash overlay
      if (state.flashT > 0) {
        const a = 0.22 * (state.flashT / FEEL.hitFlashTime);
        ctx.fillStyle = `rgba(255, 80, 80, ${a})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.restore();
    }

    // -------------------------
    // Game loop (dt with clamp)
    // -------------------------
    function loop(ts) {
      if (!state.lastTs) state.lastTs = ts;
      const rawDt = (ts - state.lastTs) / 1000;
      state.lastTs = ts;

      // Clamp dt to avoid huge jumps when tab was hidden
      const dt = Math.min(0.033, Math.max(0.0, rawDt));

      if (state.shakeT > 0) state.shakeT = Math.max(0, state.shakeT - dt);
      if (state.flashT > 0) state.flashT = Math.max(0, state.flashT - dt);

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    // -------------------------
    // Events (pointer + keyboard)
    // -------------------------
    function onPrimaryAction(e) {
      if (e) e.preventDefault();
      requestFlap();
      // attempt flap immediately for best responsiveness
      flapNow();
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        onPrimaryAction(e);
      }
    });

    // Use pointer events to avoid touch+mouse double triggers
    canvas.addEventListener('pointerdown', onPrimaryAction, { passive: false });
    document.body.addEventListener('pointerdown', (e) => {
      // Allow tapping anywhere (menus)
      if (e.target === canvas) return;
      onPrimaryAction(e);
    }, { passive: false });

    // -------------------------
    // Init
    // -------------------------
    createParticles();
    resetRun();
    bestScore.textContent = `Best: ${state.best}`;
    setModePills();

    requestAnimationFrame(loop);
  </script>
</body>
</html>
